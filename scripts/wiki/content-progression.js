const fs = require('fs')
const path = require('path')

const Curriculum = require('../../lib/curriculum')
const GitHub = require('../../lib/networking/github')

const basePath = './data'
const TOC_PLACEHOLDER = '$TOC_PLACEHOLDER'

const aspectsMap = {
  introduction: {
    emoji: ':baby:',
    description: `If you are being introduced to the topic for the first time`,
    name: 'Introduction'
  },
  workout: {
    emoji: ':muscle:',
    description: `Theory put into practice/that’s how you achieve X points`,
    name: 'Workout'
  },
  deep: {
    emoji: ':squid:',
    description:
      'Prerequisite knowledge consisting of 2 or more  :baby:/:muscle: workouts',
    name: 'Deep'
  },
  new: {
    emoji: ':sparkles:',
    description: 'Recently added/gained traction feature',
    name: 'New'
  },
  obscura: {
    emoji: ':crystal_ball:',
    description:
      'Stories, obscure details that don’t specifically relate to a learning objective',
    name: 'Obscura'
  }
}

async function run () {
  const git = new GitHub(basePath)
  const curriculum = new Curriculum(git)

  const topicPages = generateProgressionPages(curriculum)
  topicPages.forEach(({ name, page }) => {
    fs.writeFileSync(path.join(basePath, name), page)
  })
}

run()
  .then(async res => {
    console.log('Script ran succesfully')
    process.exit(0)
  })
  .catch(err => {
    console.log(err)
    process.exit(1)
  })

function generateProgressionPages (curriculum) {
  return Object.values(curriculum.topics)
    .filter(topic => topic.slug === 'sql')
    .map(topic => ({
      name: `${topic.name}-progression.md`,
      page: generateTopicPage(topic)
    }))
}

function generateTopicPage (topic) {
  let page = '<!-- BEGIN AUTOGENERATED TOPIC PAGE -->\n'

  page += `# [${
    topic.name
  }](${topic.getExternalLink()}) topic content progression\n\n`
  page += `${TOC_PLACEHOLDER}\n`
  page += generateLinearTopicProgression(topic)
  page += generateProgressionByAspect(topic)
  page += `\n\n> :robot: Last generated at ${new Date().toUTCString()}\n`
  page += '<!-- END AUTOGENERATED TOPIC PAGE -->'

  page = insertTableOfContents(page)
  return page
}

function generateProgressionByAspect (topic) {
  let section = `## Progression by aspects
  > Given the insights are tagged with **aspects**, we can filter over the linear content progression and create learning sub-paths.
  >
  > These sub-path progressions will most likely not cover all content, but they will ensure and enforce an unified learning experience, tailor for the user wish.
  >
  > For example, a user might be interested in new additions and updates of a language, rather than introduction lessions.
  > Note that these sub-paths don't take games into consideration\n\n`

  const aspects = new Map()
  Object.entries(aspectsMap).forEach(([aspectSlug, aspectObject]) => {
    aspects.set(aspectSlug, {
      ...aspectObject,
      courses: {}
    })
  })

  topic.getOrderedCourses().forEach(course => {
    course.getOrderedWorkouts().forEach(workout => {
      workout.insights
        .concat(workout.exercises)
        .concat(workout.game)
        .filter(Boolean)
        .forEach(insight => {
          insight.metadata.tags.forEach(tag => {
            const currentAspectObject = aspects.get(tag)
            if (currentAspectObject) {
              if (!currentAspectObject.courses[course.slug]) {
                currentAspectObject.courses[course.slug] = {
                  insights: [],
                  exercises: [],
                  header: `[${course.name}](${course.getExternalLink()})`
                }
              }
              if (insight.metadata.type === 'normal') {
                currentAspectObject.courses[course.slug].insights.push(insight)
              } else if (insight.metadata.type === 'exercise') {
                currentAspectObject.courses[course.slug].exercises.push(insight)
              }
              aspects.set(tag, currentAspectObject)
            }
          })
        })
    })
  })

  aspects.forEach((aspectObject, aspectSlug) => {
    section += `### ${aspectObject.emoji} ${aspectObject.name}\n`
    section += `> ${aspectObject.description}\n\n`
    if (Object.keys(aspectObject.courses).length === 0) {
      section += `:exclamation: There are no insights in topic ${
        topic.name
      } tagged with this aspect.\n`
    } else {
      Object.entries(aspectObject.courses).forEach(
        ([courseSlug, { insights, exercises, header }]) => {
          section += `#### ${header}\n`
          if (insights.length > 0) {
            section += '- Insights:\n'
            insights.forEach(insight => {
              section += `  - [${insight.slug}](${insight.getExternalLink()})\n`
            })
          }
          if (exercises.length > 0) {
            section += '- Exercises:\n'
            exercises.forEach(exercise => {
              section += `  - [${
                exercise.slug
              }](${exercise.getExternalLink()})\n`
            })
          }
        }
      )
    }
  })

  return section
}

function insertTableOfContents (page) {
  if (page.indexOf(TOC_PLACEHOLDER) === -1) {
    return page
  }
  let tableOfContents = `## Table of Contents\n`
  page.split('\n').forEach(line => {
    if (line.indexOf('##') !== -1 && line.indexOf('###') === -1) {
      const parsedLine = removeMarkdown(line)
      tableOfContents += `- [${parsedLine}](#${slugify(parsedLine)})\n`
    }
    if (line.indexOf('###') !== -1 && line.indexOf('####') === -1) {
      const parsedLine = removeMarkdown(line)
      tableOfContents += `   - [${parsedLine}](#${slugify(parsedLine)})\n`
    }
    if (line.indexOf('####') !== -1) {
      const parsedLine = removeMarkdown(line)
      tableOfContents += `     - [${parsedLine}](#${slugify(parsedLine)})\n`
    }
  })
  tableOfContents += '\n'
  return page.replace(TOC_PLACEHOLDER, tableOfContents)
}

function removeMarkdown (string) {
  return String(string).replace(/(?:__|[*#])|\[(.*?)\]\(.*?\)/gm, '$1')
}

function generateLinearTopicProgression (topic) {
  // linear progression
  let page = '## Linear content progression \n'
  page += `> The linear progression of content aims to cover all content, course by course, workout by workout as follows:
  > - first course is the only **core** one, denoted by its manifest
  > - the next course is denoted by the first item of the **next** array in each course manifest
  > - each course has its order of workouts designated by the **sections** field in the same aforementioned manifest
  >
  > Below are the courses and their workouts, following this progression logic.\n`
  topic.getOrderedCourses().forEach((course, index) => {
    page += generateCourseSection(course, index)
  })
  return page
}

function generateCourseSection (course, index) {
  let section = ''
  section += `### Course ${convertToRoman(index + 1)}: [${
    course.name
  }](${course.getExternalLink()})\n\n`
  course.getOrderedWorkouts().forEach((workout, index) => {
    section += generateWorkoutSection(workout, index)
  })
  section += `\n`
  return section
}

function generateWorkoutSection (workout, index) {
  let section = ''
  section += ` #### ${index + 1}. [${
    workout.slug
  }](${workout.getExternalLink()})\n\n`
  section += generateWorkoutContentsTable(workout)
  section += '\n'
  return section
}

function generateWorkoutContentsTable (workout) {
  let table = ''
  table += '| no | name | type | objectives | PQ | RQ | Quiz |\n'
  table += '|:--- | --- | --- | --- | --- | --- | --- |\n'
  workout.insights
    .concat(workout.game)
    .concat(workout.exercises)
    .filter(Boolean)
    .forEach((insight, index) => {
      table += generateTableRow(insight, index)
    })
  table += '\n'
  return table
}

function generateTableRow (insight, index) {
  const name = `[${insight.slug}](${insight.getExternalLink()})`
  const type = getInsightType(insight.metadata.type)
  const objectiveEmojis = getAspectEmojis(insight.metadata.tags)

  const practiceMark =
    type === 'insight'
      ? insight.practiceQuestion ? ':white_check_mark:' : ':x:'
      : 'not applicable'
  const revisionMark =
    type === 'insight'
      ? insight.revisionQuestion ? ':white_check_mark:' : ':x:'
      : 'not applicable'
  const quizMark =
    type === 'insight'
      ? insight.quiz ? ':white_check_mark:' : ':x:'
      : 'not applicable'

  return `| ${index +
    1} | ${name} | ${type} | ${objectiveEmojis} | ${practiceMark} | ${revisionMark} | ${quizMark} |\n`
}

function getAspectEmojis (tags) {
  return tags
    .filter(tag => Object.keys(aspectsMap).includes(tag))
    .map(tag => aspectsMap[tag].emoji)
    .join(' ')
}

function getInsightType (type) {
  const gameTypes = [
    'bugScroll',
    'bugSpot',
    'fillTheGap',
    'evaluateThis',
    'refactor',
    'tetris'
  ]

  if (type === 'normal') {
    return 'insight'
  } else if (type === 'exercise') {
    return 'exercise'
  } else if (gameTypes.includes(type)) {
    return 'game'
  } else {
    return 'undefined'
  }
}

function convertToRoman (num) {
  // Create an empty string for the result
  var result = []
  // list all relevant numbers and numerals
  const numbers = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
  const roman = [
    'M',
    'CM',
    'D',
    'CD',
    'C',
    'XC',
    'L',
    'XL',
    'X',
    'IX',
    'V',
    'IV',
    'I'
  ]
  // Loop through the numbers while the number is greater than the number, keep looping
  numbers.map((number, i) => {
    while (num >= number) {
      // add numerals as you go eg. 55 --> loop numbers, find L, loop again, find V
      result += roman[i]
      num -= number
    }
  })
  return result
}

function slugify (text) {
  return text
    .toString()
    .toLowerCase()
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(/[^\w-]+/g, '') // Remove all non-word chars
    .replace(/--+/g, '-') // Replace multiple - with single -
    .replace(/^-+/, '') // Trim - from start of text
    .replace(/-+$/, '') // Trim - from end of text
}
